// <copyright file="StageSceneValidationTests.cs" company="Ωmega Spiral">
// Copyright (c) Ωmega Spiral. All rights reserved.
// </copyright>

using GdUnit4;
using Godot;
using static GdUnit4.Assertions;

namespace OmegaSpiral.Tests.Integration.UI
{
    /// <summary>
    /// Integration tests validating that all stage scenes exist, are loadable, and parseable.
    /// Uses a simple data-driven approach with an array of stage definitions.
    /// KISS principle: No mocking, just validate the actual scene files work.
    /// </summary>
    [TestSuite]
    public class StageSceneValidationTests
    {
        /// <summary>
        /// Defines a stage for testing.
        /// </summary>
        /// <param name="Name">Human-readable stage name.</param>
        /// <param name="ScenePath">Godot resource path to the scene file.</param>
        /// <param name="StageNumber">Stage number (1-5) for organization.</param>
        /// <param name="Description">Brief description of stage aesthetic/theme.</param>
        public record StageDefinition(
            string Name,
            string ScenePath,
            int StageNumber,
            string Description);

        /// <summary>
        /// All stage scenes that should be loadable in the game.
        /// Add new stages here as they're developed.
        /// </summary>
        public static readonly StageDefinition[] AllStages =
        {
            // Stage 1: Ghost Terminal (CRT Terminal aesthetic)
            new("Ghost Terminal - Boot Sequence",
                "res://source/stages/ghost/scenes/boot_sequence.tscn",
                1,
                "Boot sequence entry point"),

            new("Ghost Terminal - Opening Monologue",
                "res://source/stages/ghost/scenes/opening_monologue.tscn",
                1,
                "Opening monologue scene"),

            new("Ghost Terminal - Question 1 Name",
                "res://source/stages/ghost/scenes/question_1_name.tscn",
                1,
                "First question about player name"),

            new("Ghost Terminal - Question 2 Bridge",
                "res://source/stages/ghost/scenes/question_2_bridge.tscn",
                1,
                "Question about bridge choice"),

            new("Ghost Terminal - Question 3 Voice",
                "res://source/stages/ghost/scenes/question_3_voice.tscn",
                1,
                "Question about voice preference"),

            new("Ghost Terminal - Question 4 Name 2",
                "res://source/stages/ghost/scenes/question_4_name.tscn",
                1,
                "Second name question"),

            new("Ghost Terminal - Question 5 Secret",
                "res://source/stages/ghost/scenes/question_5_secret.tscn",
                1,
                "Secret question"),

            new("Ghost Terminal - Question 6 Continue",
                "res://source/stages/ghost/scenes/question_6_continue.tscn",
                1,
                "Continue question"),

            new("Ghost Terminal - Terminal Base",
                "res://source/stages/ghost/scenes/terminal_base.tscn",
                1,
                "Terminal base scene"),

            // Stage 2: Echo Hub (NetHack/ASCII aesthetic)
            new("Echo Hub - Hub",
                "res://source/stages/stage_2/echo_hub.tscn",
                2,
                "NetHack-style ASCII dungeon exploration hub"),

            new("Echo Hub - Dungeon",
                "res://source/stages/stage_2/echo_dungeon.tscn",
                2,
                "Dungeon exploration scene"),

            new("Echo Hub - Interlude",
                "res://source/stages/stage_2/echo_interlude.tscn",
                2,
                "Interlude scene between exploration"),

            new("Echo Hub - Nethack Sequence",
                "res://source/stages/stage_2/nethack/nethack_sequence.tscn",
                2,
                "Nethack sequence scene"),

            // Stage 3: Echo Vault (Wizardry aesthetic)
            new("Echo Vault - Hub",
                "res://source/stages/stage_3/echo_vault_hub.tscn",
                3,
                "Wizardry party creation and management hub"),

            new("Echo Vault - Combat",
                "res://source/stages/stage_3/echo_vault_combat.tscn",
                3,
                "Wizardry-style turn-based combat"),

            new("Echo Vault - Finale",
                "res://source/stages/stage_3/echo_vault_finale.tscn",
                3,
                "Stage 3 conclusion scene"),

            new("Echo Vault - Mirror Selection",
                "res://source/stages/stage_3/1_mirror_selection/mirror_selection.tscn",
                3,
                "Mirror selection scene"),

            new("Echo Vault - Character Selection",
                "res://source/stages/stage_3/2_character_selection/character_selection.tscn",
                3,
                "Character selection scene"),

            new("Echo Vault - Combat Test",
                "res://source/stages/stage_3/3_combat_test/never_go_alone_combat.tscn",
                3,
                "Combat test scene"),

            new("Echo Vault - Never Go Alone",
                "res://source/stages/stage_3/4_final_selection/never_go_alone.tscn",
                3,
                "Never go alone final scene"),

            new("Echo Vault - Never Go Alone Stage",
                "res://source/stages/stage_3/4_final_selection/never_go_alone_stage.tscn",
                3,
                "Never go alone stage"),

            new("Echo Vault - Wizardry Party",
                "res://source/stages/stage_3/4_final_selection/wizardry_party.tscn",
                3,
                "Wizardry party scene"),

            // Stage 4: Tile Dungeon (Ultima/Overworld aesthetic)
            new("Tile Dungeon",
                "res://source/stages/stage_4/tile_dungeon.tscn",
                4,
                "Ultima-style tile-based overworld"),

            new("Stage 4 - Field Combat",
                "res://source/stages/stage_4/field_combat.tscn",
                4,
                "Field combat scene"),

            new("Stage 4 - Pixel Combat",
                "res://source/stages/stage_4/pixel_combat.tscn",
                4,
                "Pixel combat scene"),

            // Stage 5: Fractured Escape (Modern/3D aesthetic)
            // TODO: Add Stage 5 scenes as they are developed

            // Menu scenes (required for navigation)
            new("Press Start Menu",
                "res://source/stages/main_menu/press_start_menu.tscn",
                0,
                "Initial press start screen with mood selection"),
        };

        /// <summary>
        /// LEVEL 1: Validates that all stage scene files physically exist in the project.
        /// This test does NOT require Godot runtime - it's a pure file system check.
        /// Fast and catches missing files immediately.
        /// </summary>
        [TestCase]
        [RequireGodotRuntime]
        public static void AllStageSceneFilesExistOnFileSystem()
        {
            var failures = new List<string>();

            foreach (var stage in AllStages)
            {
                var fsPath = ProjectSettings.GlobalizePath(stage.ScenePath);
                if (!File.Exists(fsPath))
                {
                    failures.Add($"[Stage {stage.StageNumber}] {stage.Name}: File not found at {fsPath}");
                }
            }

            if (failures.Count > 0)
            {
                var message = $"Missing {failures.Count} stage scene file(s):\n" +
                              string.Join("\n", failures);
                AssertThat(failures.Count).IsEqual(0)
                    .OverrideFailureMessage(message);
            }
        }

        /// <summary>
        /// LEVEL 2: Validates that Godot's ResourceLoader recognizes all stage scenes.
        /// This ensures the .tscn files are valid Godot resources.
        /// Requires Godot runtime but doesn't instantiate scenes (faster than full load).
        /// </summary>
        [TestCase]
        [RequireGodotRuntime]
        public static void AllStageScenesAreRecognizedByResourceLoader()
        {
            var failures = new List<string>();

            foreach (var stage in AllStages)
            {
                if (!ResourceLoader.Exists(stage.ScenePath))
                {
                    failures.Add($"[Stage {stage.StageNumber}] {stage.Name}: " +
                                 $"ResourceLoader cannot find {stage.ScenePath}");
                }
            }

            if (failures.Count > 0)
            {
                var message = $"{failures.Count} stage scene(s) not recognized by Godot:\n" +
                              string.Join("\n", failures);
                AssertThat(failures.Count).IsEqual(0)
                    .OverrideFailureMessage(message);
            }
        }

        /// <summary>
        /// LEVEL 3: Validates that all stage scenes can be loaded and parsed as PackedScenes.
        /// This is the most comprehensive test - ensures scenes are valid and instantiable.
        /// Catches corrupt scene files, missing dependencies, or parse errors.
        /// </summary>
        [TestCase]
        [RequireGodotRuntime]
        public static void AllStageScenesCanBeLoadedAsPackedScenes()
        {
            var failures = new List<string>();

            foreach (var stage in AllStages)
            {
                var scene = GD.Load<PackedScene>(stage.ScenePath);
                if (scene == null)
                {
                    failures.Add($"[Stage {stage.StageNumber}] {stage.Name}: " +
                                 $"Failed to load as PackedScene from {stage.ScenePath}");
                }
            }

            if (failures.Count > 0)
            {
                var message = $"{failures.Count} stage scene(s) failed to load:\n" +
                              string.Join("\n", failures);
                AssertThat(failures.Count).IsEqual(0)
                    .OverrideFailureMessage(message);
            }
        }

        /// <summary>
        /// Validates that each stage number (1-4) has at least one scene defined.
        /// Stage 5 is not yet developed and is excluded.
        /// Ensures we haven't accidentally removed a stage from the test array.
        /// </summary>
        [TestCase]
        public static void AllStageNumbersHaveAtLeastOneScene()
        {
            var missingStages = new List<int>();

            for (int stageNum = 1; stageNum <= 4; stageNum++)
            {
                var hasScene = Array.Exists(AllStages, s => s.StageNumber == stageNum);
                if (!hasScene)
                {
                    missingStages.Add(stageNum);
                }
            }

            if (missingStages.Count > 0)
            {
                var message = $"Stage number(s) {string.Join(", ", missingStages)} " +
                              "have no scenes defined in test array";
                AssertThat(missingStages.Count).IsEqual(0)
                    .OverrideFailureMessage(message);
            }
        }

        /// <summary>
        /// Validates that the StageSelectMenu constants reference scenes that exist in test array.
        /// This ensures consistency between menu definitions and actual scene availability.
        /// Stage 5 is not yet developed and is excluded.
        /// </summary>
        [TestCase]
        public static void StageSelectMenuConstantsMatchTestArray()
        {
            // Expected paths from StageSelectMenu.cs (excluding Stage 5 which is not developed)
            var expectedPaths = new[]
            {
                "res://source/stages/ghost/scenes/opening_monologue.tscn",  // Stage 1 starting scene
                "res://source/stages/stage_2/echo_hub.tscn",                 // Stage 2 starting scene
                "res://source/stages/stage_3/echo_vault_hub.tscn",           // Stage 3 starting scene
                "res://source/stages/stage_4/tile_dungeon.tscn",             // Stage 4 starting scene
                // Stage 5 (Fractured Escape) is under development
            };

            var mismatches = new List<string>();

            foreach (var expectedPath in expectedPaths)
            {
                var existsInArray = Array.Exists(AllStages, s => s.ScenePath == expectedPath);
                if (!existsInArray)
                {
                    mismatches.Add($"Expected scene {expectedPath} is not in test array");
                }
            }

            if (mismatches.Count > 0)
            {
                var message = "Test array missing expected stage scenes:\n" +
                              string.Join("\n", mismatches) +
                              "\n\nUpdate AllStages array in StageSceneValidationTests.cs";
                AssertThat(mismatches.Count).IsEqual(0)
                    .OverrideFailureMessage(message);
            }
        }
    }
}
